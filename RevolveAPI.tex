\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[SC17]{SuperComputing}{November 2017}{Denver, Colorado, USA} 
\acmYear{1997}
\copyrightyear{2017}

\acmPrice{15.00}


\begin{document}
\title{High-level python abstractions for data management in inversion problems}
%\titlenote{Produces the permission block, and
%  copyright information}
\subtitle{Checkpointing, done beautifully.}
%\subtitlenote{The full version of the author's guide is available as
%  \texttt{acmart.pdf} document}


\author{Navjot Kukreja}
\affiliation{%
  \institution{Imperial College London}
  \streetaddress{Kensington}
  \city{London}
  \postcode{SW7 2AZ}
  \country{UK}}
\author{Jan H\"uckelheim}
\affiliation{%
  \institution{Imperial College London}
  \streetaddress{Kensington}
  \city{London}
  \postcode{SW7 2AZ}
  \country{UK}}
\author{Michael Lange}
\affiliation{%
  \institution{Imperial College London}
  \streetaddress{Kensington}
  \city{London}
  \postcode{SW7 2AZ}
  \country{UK}}
\author{Who Else}
\affiliation{%
  \institution{Imperial College London}
  \streetaddress{Kensington}
  \city{London}
  \postcode{SW7 2AZ}
  \country{UK}}

\renewcommand\shortauthors{Kukreja, N. et al}

\begin{abstract} TODO
The computation of adjoints in optimisation and inverse design problems requires storing intermediate data. The available memory size sets a limit to this, and necessitates recomputation in some instances. Revolve checkpointing offers an optimal schedule that trades computational cost for smaller memory footprints. Integrating Revolve into a modern python HPC code and combining it with code generation is not straightforward. We present an API that makes checkpointing accessible from a DSL-based code generation environment and present a benchmark study. TODO.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011074.10011075.10011077</concept_id>
<concept_desc>Software and its engineering~Software design engineering</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Software design engineering}
%
% End generated code
%


\keywords{HPC, Code generation, API, Checkpointing, Adjoint, Inverse Problems}


\maketitle

\section{Introduction}
Seismic inversion, and more specifically Full Waveform Inversion (FWI)
is a computationally heavy technique that uses data from seismic wave
propagation experiments to calculate physical parameters of the
earth's subsurface. In case of FWI, this additional information on the
physical parameters drives the generation of better subsurface
images (CITE). An FWI problem is setup as an optimization problem using
a gradient-based optimization algorithm with the objective function
being minimised is the misfit between the simulated data and the
observed data received at the receivers. A finite-difference
discretization of one of the forms of the wave equation acts as the
constraint for the optimization. Since the gradient is calculated using the
adjoint-state method, by the correlation between the fields in forward
and adjoint (reverse) mode (CITE), the method requires that the forward and
adjoint field be known for each time step in the
simulation. Considering that the typical domain for such a setup is 3
dimensional with 1000 points in each dimension, the field requires
$1000 \times 1000 \times 1000 \times 4 = 4 \times 10^{9} $ bytes ( 4
GB) of memory for a single timestep. Since the simulation is run for a
typical $3000$ time-steps, storing the entire forward field in memory
would require $12 TB$ of memory which is prohibitively high. We
discuss this in section \ref{sec:inversion_devito}. 

Previous work on similar inverse problems led to the \emph{Revolve}
algorithm \cite{griewank2000} and the associated C++ tool which
provides an optimal schedule at which to store checkpoints,
i.e. states from which the forward simulation can be restored. This
algorithm is further discussed in section \ref{sec:revolve}.

The tool and the algorithm, however, only provide the schedule to be
used for checkpointing. Although this eases some of the complexity of
the application code using the algorithm, the glue code required to
manage the forward and adjoint runs is still quite complex. This acts
as a deterrent to more widespread use of the algorithm in the
community. 

In this paper we describe how the algorithm can be combined with code
generation to make checkpointing much more accessible. The software that
can enable this is described in section \ref{sec:api}. 

The performance impact of using the checkpointing scheme, as well as
the effect of the size of memory available is studied in section
\ref{sec:experiment}. 

Motivation: Why do we need to connect revolve and a python seismic inversion code? What is there to learn for others? How does our work help readers and the world?

\section{Seismic inversion and Devito}
\label{sec:inversion_devito}
Some context on seismic imaging, the PDEs, the method. Why use
adjoints. Why is this problem time-dependent. Why do we need a lot of
data.
Code generation, references to previous papers about Devito. Why not
be brave and write this in Fortran.

\section{Revolve}
\label{sec:revolve}
How does revolve work and save memory. How do others use it, why is this painful.

\section{API: Connecting Revolve with Devito}
\label{sec:api}
This is the core of the paper.

\section{Test case, Results}
\label{sec:experiment}
A nice test case that can be scaled up in size easily. Timings for different mesh sizes, with different amounts of memory set as the upper limit.

\section{Conclusions}
This work was highly successful, but more work could be done.

\begin{acks}
  The authors are very grateful to Mathias Louboutin (?), Simon Funke
  (?). 
\end{acks}


\bibliographystyle{ACM-Reference-Format}
\bibliography{bib_checkpointing} 

\end{document}
